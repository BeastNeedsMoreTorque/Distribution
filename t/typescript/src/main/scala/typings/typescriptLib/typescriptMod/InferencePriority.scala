package typings
package typescriptLib.typescriptMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSImport("typescript", "InferencePriority")
@js.native
object InferencePriority extends js.Object {
  /* 64 */ val AlwaysStrict: typescriptLib.typescriptMod.tsNs.InferencePriority.AlwaysStrict with scala.Double = js.native
  /* 2 */ val HomomorphicMappedType: typescriptLib.typescriptMod.tsNs.InferencePriority.HomomorphicMappedType with scala.Double = js.native
  /* 16 */ val LiteralKeyof: typescriptLib.typescriptMod.tsNs.InferencePriority.LiteralKeyof with scala.Double = js.native
  /* 4 */ val MappedTypeConstraint: typescriptLib.typescriptMod.tsNs.InferencePriority.MappedTypeConstraint with scala.Double = js.native
  /* 1 */ val NakedTypeVariable: typescriptLib.typescriptMod.tsNs.InferencePriority.NakedTypeVariable with scala.Double = js.native
  /* 32 */ val NoConstraints: typescriptLib.typescriptMod.tsNs.InferencePriority.NoConstraints with scala.Double = js.native
  /* 28 */ val PriorityImpliesCombination: typescriptLib.typescriptMod.tsNs.InferencePriority.PriorityImpliesCombination with scala.Double = js.native
  /* 8 */ val ReturnType: typescriptLib.typescriptMod.tsNs.InferencePriority.ReturnType with scala.Double = js.native
  @JSBracketAccess
  def apply(value: scala.Double): js.UndefOr[typescriptLib.typescriptMod.tsNs.InferencePriority with scala.Double] = js.native
}


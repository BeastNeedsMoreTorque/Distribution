package typings
package plottableLib.buildSrcScalesQuantitativeScaleMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
@js.native
class QuantitativeScale[D] ()
  extends plottableLib.buildSrcScalesScaleMod.Scale[D, scala.Double]
     with plottableLib.buildSrcScalesMod.ITransformableScale {
  var _domainMax: js.Any = js.native
  var _domainMin: js.Any = js.native
  var _padProportion: js.Any = js.native
  var _paddingExceptionsProviders: js.Any = js.native
  var _snappingDomainEnabled: js.Any = js.native
  var _tickGenerator: js.Any = js.native
  /* protected */ def _defaultExtent(): js.Array[D] = js.native
  /* protected */ def _expandSingleValueDomain(singleValueDomain: js.Array[D]): js.Array[D] = js.native
  /* protected */ def _getUnboundedExtent(): js.Array[D] = js.native
  /* protected */ def _getUnboundedExtent(ignoreAttachState: scala.Boolean): js.Array[D] = js.native
  /**
       * Given a domain, expands its domain onto "nice" values, e.g. whole
       * numbers.
       */
  /* protected */ def _niceDomain(domain: js.Array[D]): js.Array[D] = js.native
  /**
       * Given a domain, expands its domain onto "nice" values, e.g. whole
       * numbers.
       */
  /* protected */ def _niceDomain(domain: js.Array[D], count: scala.Double): js.Array[D] = js.native
  /* private */ def _padDomain(domain: js.Any): js.Any = js.native
  /**
       * Adds a padding exception provider.
       * If one end of the domain is set to an excepted value as a result of autoDomain()-ing,
       * that end of the domain will not be padded.
       *
       * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
       * @returns {QuantitativeScale} The calling QuantitativeScale.
       */
  def addPaddingExceptionsProvider(provider: plottableLib.buildSrcScalesMod.IPaddingExceptionsProvider[D]): this.type = js.native
  /**
       * Gets the array of tick values generated by the default algorithm.
       */
  def defaultTicks(): js.Array[D] = js.native
  /**
       * Gets the upper end of the domain.
       *
       * @return {D}
       */
  def domainMax(): D = js.native
  /**
       * Sets the upper end of the domain.
       *
       * @return {QuantitativeScale} The calling QuantitativeScale.
       */
  def domainMax(domainMax: D): this.type = js.native
  /**
       * Gets the lower end of the domain.
       *
       * @return {D}
       */
  def domainMin(): D = js.native
  /**
       * Sets the lower end of the domain.
       *
       * @return {QuantitativeScale} The calling QuantitativeScale.
       */
  def domainMin(domainMin: D): this.type = js.native
  /**
       * Returns the current transformed domain of the scale. This must be a
       * numerical range in the same coordinate space used for
       * `scaleTransformation`.
       */
  /* CompleteClass */
  override def getTransformationDomain(): js.Tuple2[scala.Double, scala.Double] = js.native
  /**
       * Gets the full extent of the transformation domain.
       */
  /* CompleteClass */
  override def getTransformationExtent(): js.Tuple2[scala.Double, scala.Double] = js.native
  /**
       * Computes the domain value corresponding to a supplied range value.
       *
       * @param {number} value: A value from the Scale's range.
       * @returns {D} The domain value corresponding to the supplied range value.
       */
  def invert(value: scala.Double): D = js.native
  /**
       * Returns value in *Transformation Space* for the provided *screen space*.
       */
  /* CompleteClass */
  override def invertedTransformation(value: scala.Double): scala.Double = js.native
  /**
       * Gets the padding proportion.
       */
  def padProportion(): scala.Double = js.native
  /**
       * Sets the padding porportion.
       * When autoDomain()-ing, the computed domain will be expanded by this proportion,
       * then rounded to human-readable values.
       *
       * @param {number} padProportion The padding proportion. Passing 0 disables padding.
       * @returns {QuantitativeScale} The calling QuantitativeScale.
       */
  def padProportion(padProportion: scala.Double): this.type = js.native
  /**
       * Translates the scale by a number of pixels.
       *
       * @param {number} [translateAmount] The translation amount in screen space
       */
  /* CompleteClass */
  override def pan(translateAmount: scala.Double): scala.Unit = js.native
  /**
       * Removes the padding exception provider.
       *
       * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
       * @returns {QuantitativeScale} The calling QuantitativeScale.
       */
  def removePaddingExceptionsProvider(provider: plottableLib.buildSrcScalesMod.IPaddingExceptionsProvider[D]): this.type = js.native
  /**
       * Returns value in *screen space* for the given domain value.
       */
  /* CompleteClass */
  override def scaleTransformation(value: scala.Double): scala.Double = js.native
  /**
       * Directly set the transformation domain. Instead of calling `.zoom` or
       * `.pan` perform calculations relative to the current domain, this can but
       * used to pan/zoom to an exact domain interval (in transformation space).
       */
  /* CompleteClass */
  override def setTransformationDomain(domain: js.Tuple2[scala.Double, scala.Double]): scala.Unit = js.native
  /**
       * Gets whether or not the scale snaps its domain to nice values.
       */
  def snappingDomainEnabled(): scala.Boolean = js.native
  /**
       * Sets whether or not the scale snaps its domain to nice values.
       */
  def snappingDomainEnabled(snappingDomainEnabled: scala.Boolean): this.type = js.native
  /**
       * Gets the TickGenerator.
       */
  def tickGenerator(): plottableLib.buildSrcScalesTickGeneratorsMod.ITickGenerator[D] = js.native
  /**
       * Sets the TickGenerator
       *
       * @param {TickGenerator} generator
       * @return {QuantitativeScale} The calling QuantitativeScale.
       */
  def tickGenerator(generator: plottableLib.buildSrcScalesTickGeneratorsMod.ITickGenerator[D]): this.type = js.native
  /**
       * Apply the magnification with the floating point `magnifyAmount` centered
       * at the `centerValue` coordinate.
       *
       * @param {number} [magnifyAmount] The floating point zoom amount. `1.0` is
       * no zoom change.
       * @param {number} [centerValue] The coordinate of the mouse in screen
       * space.
       */
  /* CompleteClass */
  override def zoom(magnifyAmount: scala.Double, centerValue: scala.Double): scala.Unit = js.native
}

@JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
@js.native
object QuantitativeScale extends js.Object {
  var _DEFAULT_NUM_TICKS: scala.Double = js.native
}


package typings.gapiClientDiscovery.gapi.client.discovery

import typings.gapiClientDiscovery.anon.Discriminant
import typings.gapiClientDiscovery.anon.Required
import typings.std.Record
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait JsonSchema extends js.Object {
  /** A reference to another schema. The value of this property is the "id" of another schema. */
  @JSName("$ref")
  var $ref: js.UndefOr[String] = js.undefined
  /** If this is a schema for an object, this property is the schema for any additional properties with dynamic keys on this object. */
  var additionalProperties: js.UndefOr[JsonSchema] = js.undefined
  /** Additional information about this property. */
  var annotations: js.UndefOr[Required] = js.undefined
  /** The default value of this property (if one exists). */
  var default: js.UndefOr[String] = js.undefined
  /** A description of this object. */
  var description: js.UndefOr[String] = js.undefined
  /** Values this parameter may take (if it is an enum). */
  var enum: js.UndefOr[js.Array[String]] = js.undefined
  /** The descriptions for the enums. Each position maps to the corresponding value in the "enum" array. */
  var enumDescriptions: js.UndefOr[js.Array[String]] = js.undefined
  /**
    * An additional regular expression or key that helps constrain the value. For more details see:
    * http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.23
    */
  var format: js.UndefOr[String] = js.undefined
  /** Unique identifier for this schema. */
  var id: js.UndefOr[String] = js.undefined
  /** If this is a schema for an array, this property is the schema for each element in the array. */
  var items: js.UndefOr[JsonSchema] = js.undefined
  /** Whether this parameter goes in the query or the path for REST requests. */
  var location: js.UndefOr[String] = js.undefined
  /** The maximum value of this parameter. */
  var maximum: js.UndefOr[String] = js.undefined
  /** The minimum value of this parameter. */
  var minimum: js.UndefOr[String] = js.undefined
  /** The regular expression this parameter must conform to. Uses Java 6 regex format: http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html */
  var pattern: js.UndefOr[String] = js.undefined
  /** If this is a schema for an object, list the schema for each property of this object. */
  var properties: js.UndefOr[Record[String, JsonSchema]] = js.undefined
  /**
    * The value is read-only, generated by the service. The value cannot be modified by the client. If the value is included in a POST, PUT, or PATCH
    * request, it is ignored by the service.
    */
  var readOnly: js.UndefOr[Boolean] = js.undefined
  /** Whether this parameter may appear multiple times. */
  var repeated: js.UndefOr[Boolean] = js.undefined
  /** Whether the parameter is required. */
  var required: js.UndefOr[Boolean] = js.undefined
  /** The value type for this schema. A list of values can be found here: http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.1 */
  var `type`: js.UndefOr[String] = js.undefined
  /**
    * In a variant data type, the value of one property is used to determine how to interpret the entire entity. Its value must exist in a map of
    * descriminant values to schema names.
    */
  var variant: js.UndefOr[Discriminant] = js.undefined
}

object JsonSchema {
  @scala.inline
  def apply(
    $ref: String = null,
    additionalProperties: JsonSchema = null,
    annotations: Required = null,
    default: String = null,
    description: String = null,
    enum: js.Array[String] = null,
    enumDescriptions: js.Array[String] = null,
    format: String = null,
    id: String = null,
    items: JsonSchema = null,
    location: String = null,
    maximum: String = null,
    minimum: String = null,
    pattern: String = null,
    properties: Record[String, JsonSchema] = null,
    readOnly: js.UndefOr[Boolean] = js.undefined,
    repeated: js.UndefOr[Boolean] = js.undefined,
    required: js.UndefOr[Boolean] = js.undefined,
    `type`: String = null,
    variant: Discriminant = null
  ): JsonSchema = {
    val __obj = js.Dynamic.literal()
    if ($ref != null) __obj.updateDynamic("$ref")($ref.asInstanceOf[js.Any])
    if (additionalProperties != null) __obj.updateDynamic("additionalProperties")(additionalProperties.asInstanceOf[js.Any])
    if (annotations != null) __obj.updateDynamic("annotations")(annotations.asInstanceOf[js.Any])
    if (default != null) __obj.updateDynamic("default")(default.asInstanceOf[js.Any])
    if (description != null) __obj.updateDynamic("description")(description.asInstanceOf[js.Any])
    if (enum != null) __obj.updateDynamic("enum")(enum.asInstanceOf[js.Any])
    if (enumDescriptions != null) __obj.updateDynamic("enumDescriptions")(enumDescriptions.asInstanceOf[js.Any])
    if (format != null) __obj.updateDynamic("format")(format.asInstanceOf[js.Any])
    if (id != null) __obj.updateDynamic("id")(id.asInstanceOf[js.Any])
    if (items != null) __obj.updateDynamic("items")(items.asInstanceOf[js.Any])
    if (location != null) __obj.updateDynamic("location")(location.asInstanceOf[js.Any])
    if (maximum != null) __obj.updateDynamic("maximum")(maximum.asInstanceOf[js.Any])
    if (minimum != null) __obj.updateDynamic("minimum")(minimum.asInstanceOf[js.Any])
    if (pattern != null) __obj.updateDynamic("pattern")(pattern.asInstanceOf[js.Any])
    if (properties != null) __obj.updateDynamic("properties")(properties.asInstanceOf[js.Any])
    if (!js.isUndefined(readOnly)) __obj.updateDynamic("readOnly")(readOnly.get.asInstanceOf[js.Any])
    if (!js.isUndefined(repeated)) __obj.updateDynamic("repeated")(repeated.get.asInstanceOf[js.Any])
    if (!js.isUndefined(required)) __obj.updateDynamic("required")(required.get.asInstanceOf[js.Any])
    if (`type` != null) __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
    if (variant != null) __obj.updateDynamic("variant")(variant.asInstanceOf[js.Any])
    __obj.asInstanceOf[JsonSchema]
  }
}


package typings.arrayDotPrototypeDotFlat

import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`0`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`1`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`2`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`3`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`4`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`5`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`6`
import typings.arrayDotPrototypeDotFlat.arrayDotPrototypeDotFlatNumbers.`7`
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSImport("array.prototype.flat/implementation", JSImport.Namespace)
@js.native
object implementationMod extends js.Object {
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth. If no depth is provided, flat method defaults to the depth of 1.
    *
    * @param depth The maximum recursion depth
    */
  def apply(receiver: js.Array[_]): js.Array[_] = js.native
  def apply(receiver: js.Array[_], depth: Double): js.Array[_] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[U], depth: `0`): js.Array[U] = js.native
  def apply[U](receiver: js.Array[js.Array[U]], depth: `1`): js.Array[U] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[js.Array[js.Array[U]]], depth: `2`): js.Array[U] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[js.Array[js.Array[js.Array[U]]]], depth: `3`): js.Array[U] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[js.Array[js.Array[js.Array[js.Array[U]]]]], depth: `4`): js.Array[U] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[U]]]]]], depth: `5`): js.Array[U] = js.native
  /**
    * Returns a new array with all sub-array elements concatenated into it recursively up to the
    * specified depth.
    *
    * @param depth The maximum recursion depth
    */
  def apply[U](receiver: js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[U]]]]]]], depth: `6`): js.Array[U] = js.native
  def apply[U](
    receiver: js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[js.Array[U]]]]]]]],
    depth: `7`
  ): js.Array[U] = js.native
}


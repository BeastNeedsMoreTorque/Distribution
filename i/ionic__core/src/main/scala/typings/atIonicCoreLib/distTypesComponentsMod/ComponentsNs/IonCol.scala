package typings
package atIonicCoreLib.distTypesComponentsMod.ComponentsNs

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait IonCol extends js.Object {
  /**
    * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
    */
  var offset: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetLg: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetMd: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetSm: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetXl: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetXs: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
    */
  var pull: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullLg: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullMd: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullSm: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullXl: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullXs: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
    */
  var push: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushLg: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushMd: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushSm: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushXl: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushXs: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var size: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeLg: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeMd: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeSm: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeXl: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeXs: js.UndefOr[java.lang.String] = js.undefined
}

object IonCol {
  @scala.inline
  def apply(
    offset: java.lang.String = null,
    offsetLg: java.lang.String = null,
    offsetMd: java.lang.String = null,
    offsetSm: java.lang.String = null,
    offsetXl: java.lang.String = null,
    offsetXs: java.lang.String = null,
    pull: java.lang.String = null,
    pullLg: java.lang.String = null,
    pullMd: java.lang.String = null,
    pullSm: java.lang.String = null,
    pullXl: java.lang.String = null,
    pullXs: java.lang.String = null,
    push: java.lang.String = null,
    pushLg: java.lang.String = null,
    pushMd: java.lang.String = null,
    pushSm: java.lang.String = null,
    pushXl: java.lang.String = null,
    pushXs: java.lang.String = null,
    size: java.lang.String = null,
    sizeLg: java.lang.String = null,
    sizeMd: java.lang.String = null,
    sizeSm: java.lang.String = null,
    sizeXl: java.lang.String = null,
    sizeXs: java.lang.String = null
  ): IonCol = {
    val __obj = js.Dynamic.literal()
    if (offset != null) __obj.updateDynamic("offset")(offset)
    if (offsetLg != null) __obj.updateDynamic("offsetLg")(offsetLg)
    if (offsetMd != null) __obj.updateDynamic("offsetMd")(offsetMd)
    if (offsetSm != null) __obj.updateDynamic("offsetSm")(offsetSm)
    if (offsetXl != null) __obj.updateDynamic("offsetXl")(offsetXl)
    if (offsetXs != null) __obj.updateDynamic("offsetXs")(offsetXs)
    if (pull != null) __obj.updateDynamic("pull")(pull)
    if (pullLg != null) __obj.updateDynamic("pullLg")(pullLg)
    if (pullMd != null) __obj.updateDynamic("pullMd")(pullMd)
    if (pullSm != null) __obj.updateDynamic("pullSm")(pullSm)
    if (pullXl != null) __obj.updateDynamic("pullXl")(pullXl)
    if (pullXs != null) __obj.updateDynamic("pullXs")(pullXs)
    if (push != null) __obj.updateDynamic("push")(push)
    if (pushLg != null) __obj.updateDynamic("pushLg")(pushLg)
    if (pushMd != null) __obj.updateDynamic("pushMd")(pushMd)
    if (pushSm != null) __obj.updateDynamic("pushSm")(pushSm)
    if (pushXl != null) __obj.updateDynamic("pushXl")(pushXl)
    if (pushXs != null) __obj.updateDynamic("pushXs")(pushXs)
    if (size != null) __obj.updateDynamic("size")(size)
    if (sizeLg != null) __obj.updateDynamic("sizeLg")(sizeLg)
    if (sizeMd != null) __obj.updateDynamic("sizeMd")(sizeMd)
    if (sizeSm != null) __obj.updateDynamic("sizeSm")(sizeSm)
    if (sizeXl != null) __obj.updateDynamic("sizeXl")(sizeXl)
    if (sizeXs != null) __obj.updateDynamic("sizeXs")(sizeXs)
    __obj.asInstanceOf[IonCol]
  }
}


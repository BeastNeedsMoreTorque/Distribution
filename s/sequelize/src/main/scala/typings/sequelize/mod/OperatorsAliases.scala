package typings.sequelize.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/* Inlined std.Partial<{[key: string] : symbol,   $eq  :symbol,   $ne  :symbol,   $gte  :symbol,   $gt  :symbol,   $lte  :symbol,   $lt  :symbol,   $not  :symbol,   $in  :symbol,   $notIn  :symbol,   $is  :symbol,   $like  :symbol,   $notLike  :symbol,   $iLike  :symbol,   $notILike  :symbol,   $regexp  :symbol,   $notRegexp  :symbol,   $iRegexp  :symbol,   $notIRegexp  :symbol,   $between  :symbol,   $notBetween  :symbol,   $overlap  :symbol,   $contains  :symbol,   $contained  :symbol,   $adjacent  :symbol,   $strictLeft  :symbol,   $strictRight  :symbol,   $noExtendRight  :symbol,   $noExtendLeft  :symbol,   $and  :symbol,   $or  :symbol,   $any  :symbol,   $all  :symbol,   $values  :symbol,   $col  :symbol,   $raw  :symbol}> */
trait OperatorsAliases extends js.Object {
  @JSName("$adjacent")
  var $adjacent: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$all")
  var $all: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$and")
  var $and: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$any")
  var $any: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$between")
  var $between: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$col")
  var $col: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$contained")
  var $contained: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$contains")
  var $contains: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$eq")
  var $eq: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$gt")
  var $gt: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$gte")
  var $gte: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$iLike")
  var $iLike: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$iRegexp")
  var $iRegexp: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$in")
  var $in: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$is")
  var $is: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$like")
  var $like: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$lt")
  var $lt: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$lte")
  var $lte: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$ne")
  var $ne: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$noExtendLeft")
  var $noExtendLeft: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$noExtendRight")
  var $noExtendRight: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$not")
  var $not: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notBetween")
  var $notBetween: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notILike")
  var $notILike: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notIRegexp")
  var $notIRegexp: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notIn")
  var $notIn: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notLike")
  var $notLike: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$notRegexp")
  var $notRegexp: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$or")
  var $or: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$overlap")
  var $overlap: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$raw")
  var $raw: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$regexp")
  var $regexp: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$strictLeft")
  var $strictLeft: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$strictRight")
  var $strictRight: js.UndefOr[js.Symbol] = js.undefined
  @JSName("$values")
  var $values: js.UndefOr[js.Symbol] = js.undefined
}

object OperatorsAliases {
  @scala.inline
  def apply(
    $adjacent: js.Symbol = null,
    $all: js.Symbol = null,
    $and: js.Symbol = null,
    $any: js.Symbol = null,
    $between: js.Symbol = null,
    $col: js.Symbol = null,
    $contained: js.Symbol = null,
    $contains: js.Symbol = null,
    $eq: js.Symbol = null,
    $gt: js.Symbol = null,
    $gte: js.Symbol = null,
    $iLike: js.Symbol = null,
    $iRegexp: js.Symbol = null,
    $in: js.Symbol = null,
    $is: js.Symbol = null,
    $like: js.Symbol = null,
    $lt: js.Symbol = null,
    $lte: js.Symbol = null,
    $ne: js.Symbol = null,
    $noExtendLeft: js.Symbol = null,
    $noExtendRight: js.Symbol = null,
    $not: js.Symbol = null,
    $notBetween: js.Symbol = null,
    $notILike: js.Symbol = null,
    $notIRegexp: js.Symbol = null,
    $notIn: js.Symbol = null,
    $notLike: js.Symbol = null,
    $notRegexp: js.Symbol = null,
    $or: js.Symbol = null,
    $overlap: js.Symbol = null,
    $raw: js.Symbol = null,
    $regexp: js.Symbol = null,
    $strictLeft: js.Symbol = null,
    $strictRight: js.Symbol = null,
    $values: js.Symbol = null
  ): OperatorsAliases = {
    val __obj = js.Dynamic.literal()
    if ($adjacent != null) __obj.updateDynamic("$adjacent")($adjacent.asInstanceOf[js.Any])
    if ($all != null) __obj.updateDynamic("$all")($all.asInstanceOf[js.Any])
    if ($and != null) __obj.updateDynamic("$and")($and.asInstanceOf[js.Any])
    if ($any != null) __obj.updateDynamic("$any")($any.asInstanceOf[js.Any])
    if ($between != null) __obj.updateDynamic("$between")($between.asInstanceOf[js.Any])
    if ($col != null) __obj.updateDynamic("$col")($col.asInstanceOf[js.Any])
    if ($contained != null) __obj.updateDynamic("$contained")($contained.asInstanceOf[js.Any])
    if ($contains != null) __obj.updateDynamic("$contains")($contains.asInstanceOf[js.Any])
    if ($eq != null) __obj.updateDynamic("$eq")($eq.asInstanceOf[js.Any])
    if ($gt != null) __obj.updateDynamic("$gt")($gt.asInstanceOf[js.Any])
    if ($gte != null) __obj.updateDynamic("$gte")($gte.asInstanceOf[js.Any])
    if ($iLike != null) __obj.updateDynamic("$iLike")($iLike.asInstanceOf[js.Any])
    if ($iRegexp != null) __obj.updateDynamic("$iRegexp")($iRegexp.asInstanceOf[js.Any])
    if ($in != null) __obj.updateDynamic("$in")($in.asInstanceOf[js.Any])
    if ($is != null) __obj.updateDynamic("$is")($is.asInstanceOf[js.Any])
    if ($like != null) __obj.updateDynamic("$like")($like.asInstanceOf[js.Any])
    if ($lt != null) __obj.updateDynamic("$lt")($lt.asInstanceOf[js.Any])
    if ($lte != null) __obj.updateDynamic("$lte")($lte.asInstanceOf[js.Any])
    if ($ne != null) __obj.updateDynamic("$ne")($ne.asInstanceOf[js.Any])
    if ($noExtendLeft != null) __obj.updateDynamic("$noExtendLeft")($noExtendLeft.asInstanceOf[js.Any])
    if ($noExtendRight != null) __obj.updateDynamic("$noExtendRight")($noExtendRight.asInstanceOf[js.Any])
    if ($not != null) __obj.updateDynamic("$not")($not.asInstanceOf[js.Any])
    if ($notBetween != null) __obj.updateDynamic("$notBetween")($notBetween.asInstanceOf[js.Any])
    if ($notILike != null) __obj.updateDynamic("$notILike")($notILike.asInstanceOf[js.Any])
    if ($notIRegexp != null) __obj.updateDynamic("$notIRegexp")($notIRegexp.asInstanceOf[js.Any])
    if ($notIn != null) __obj.updateDynamic("$notIn")($notIn.asInstanceOf[js.Any])
    if ($notLike != null) __obj.updateDynamic("$notLike")($notLike.asInstanceOf[js.Any])
    if ($notRegexp != null) __obj.updateDynamic("$notRegexp")($notRegexp.asInstanceOf[js.Any])
    if ($or != null) __obj.updateDynamic("$or")($or.asInstanceOf[js.Any])
    if ($overlap != null) __obj.updateDynamic("$overlap")($overlap.asInstanceOf[js.Any])
    if ($raw != null) __obj.updateDynamic("$raw")($raw.asInstanceOf[js.Any])
    if ($regexp != null) __obj.updateDynamic("$regexp")($regexp.asInstanceOf[js.Any])
    if ($strictLeft != null) __obj.updateDynamic("$strictLeft")($strictLeft.asInstanceOf[js.Any])
    if ($strictRight != null) __obj.updateDynamic("$strictRight")($strictRight.asInstanceOf[js.Any])
    if ($values != null) __obj.updateDynamic("$values")($values.asInstanceOf[js.Any])
    __obj.asInstanceOf[OperatorsAliases]
  }
}


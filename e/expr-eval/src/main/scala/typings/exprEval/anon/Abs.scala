package typings.exprEval.anon

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait Abs extends js.Object {
  var abs: js.UndefOr[Boolean] = js.undefined
  var acos: js.UndefOr[Boolean] = js.undefined
  var acosh: js.UndefOr[Boolean] = js.undefined
  var add: js.UndefOr[Boolean] = js.undefined
  var asin: js.UndefOr[Boolean] = js.undefined
  var asinh: js.UndefOr[Boolean] = js.undefined
  var assignment: js.UndefOr[Boolean] = js.undefined
  var atan: js.UndefOr[Boolean] = js.undefined
  var atanh: js.UndefOr[Boolean] = js.undefined
  var cbrt: js.UndefOr[Boolean] = js.undefined
  var ceil: js.UndefOr[Boolean] = js.undefined
  var comparison: js.UndefOr[Boolean] = js.undefined
  var concatenate: js.UndefOr[Boolean] = js.undefined
  var conditional: js.UndefOr[Boolean] = js.undefined
  var cos: js.UndefOr[Boolean] = js.undefined
  var cosh: js.UndefOr[Boolean] = js.undefined
  var divide: js.UndefOr[Boolean] = js.undefined
  var exp: js.UndefOr[Boolean] = js.undefined
  var expm1: js.UndefOr[Boolean] = js.undefined
  var factorial: js.UndefOr[Boolean] = js.undefined
  var floor: js.UndefOr[Boolean] = js.undefined
  var fndef: js.UndefOr[Boolean] = js.undefined
  var in: js.UndefOr[Boolean] = js.undefined
  var length: js.UndefOr[Boolean] = js.undefined
  var lg: js.UndefOr[Boolean] = js.undefined
  var ln: js.UndefOr[Boolean] = js.undefined
  var log: js.UndefOr[Boolean] = js.undefined
  var log10: js.UndefOr[Boolean] = js.undefined
  var log1p: js.UndefOr[Boolean] = js.undefined
  var log2: js.UndefOr[Boolean] = js.undefined
  var logical: js.UndefOr[Boolean] = js.undefined
  var max: js.UndefOr[Boolean] = js.undefined
  var min: js.UndefOr[Boolean] = js.undefined
  var multiply: js.UndefOr[Boolean] = js.undefined
  var power: js.UndefOr[Boolean] = js.undefined
  var random: js.UndefOr[Boolean] = js.undefined
  var remainder: js.UndefOr[Boolean] = js.undefined
  var round: js.UndefOr[Boolean] = js.undefined
  var sign: js.UndefOr[Boolean] = js.undefined
  var sin: js.UndefOr[Boolean] = js.undefined
  var sinh: js.UndefOr[Boolean] = js.undefined
  var sqrt: js.UndefOr[Boolean] = js.undefined
  var subtract: js.UndefOr[Boolean] = js.undefined
  var tan: js.UndefOr[Boolean] = js.undefined
  var tanh: js.UndefOr[Boolean] = js.undefined
  var trunc: js.UndefOr[Boolean] = js.undefined
}

object Abs {
  @scala.inline
  def apply(
    abs: js.UndefOr[Boolean] = js.undefined,
    acos: js.UndefOr[Boolean] = js.undefined,
    acosh: js.UndefOr[Boolean] = js.undefined,
    add: js.UndefOr[Boolean] = js.undefined,
    asin: js.UndefOr[Boolean] = js.undefined,
    asinh: js.UndefOr[Boolean] = js.undefined,
    assignment: js.UndefOr[Boolean] = js.undefined,
    atan: js.UndefOr[Boolean] = js.undefined,
    atanh: js.UndefOr[Boolean] = js.undefined,
    cbrt: js.UndefOr[Boolean] = js.undefined,
    ceil: js.UndefOr[Boolean] = js.undefined,
    comparison: js.UndefOr[Boolean] = js.undefined,
    concatenate: js.UndefOr[Boolean] = js.undefined,
    conditional: js.UndefOr[Boolean] = js.undefined,
    cos: js.UndefOr[Boolean] = js.undefined,
    cosh: js.UndefOr[Boolean] = js.undefined,
    divide: js.UndefOr[Boolean] = js.undefined,
    exp: js.UndefOr[Boolean] = js.undefined,
    expm1: js.UndefOr[Boolean] = js.undefined,
    factorial: js.UndefOr[Boolean] = js.undefined,
    floor: js.UndefOr[Boolean] = js.undefined,
    fndef: js.UndefOr[Boolean] = js.undefined,
    in: js.UndefOr[Boolean] = js.undefined,
    length: js.UndefOr[Boolean] = js.undefined,
    lg: js.UndefOr[Boolean] = js.undefined,
    ln: js.UndefOr[Boolean] = js.undefined,
    log: js.UndefOr[Boolean] = js.undefined,
    log10: js.UndefOr[Boolean] = js.undefined,
    log1p: js.UndefOr[Boolean] = js.undefined,
    log2: js.UndefOr[Boolean] = js.undefined,
    logical: js.UndefOr[Boolean] = js.undefined,
    max: js.UndefOr[Boolean] = js.undefined,
    min: js.UndefOr[Boolean] = js.undefined,
    multiply: js.UndefOr[Boolean] = js.undefined,
    power: js.UndefOr[Boolean] = js.undefined,
    random: js.UndefOr[Boolean] = js.undefined,
    remainder: js.UndefOr[Boolean] = js.undefined,
    round: js.UndefOr[Boolean] = js.undefined,
    sign: js.UndefOr[Boolean] = js.undefined,
    sin: js.UndefOr[Boolean] = js.undefined,
    sinh: js.UndefOr[Boolean] = js.undefined,
    sqrt: js.UndefOr[Boolean] = js.undefined,
    subtract: js.UndefOr[Boolean] = js.undefined,
    tan: js.UndefOr[Boolean] = js.undefined,
    tanh: js.UndefOr[Boolean] = js.undefined,
    trunc: js.UndefOr[Boolean] = js.undefined
  ): Abs = {
    val __obj = js.Dynamic.literal()
    if (!js.isUndefined(abs)) __obj.updateDynamic("abs")(abs.get.asInstanceOf[js.Any])
    if (!js.isUndefined(acos)) __obj.updateDynamic("acos")(acos.get.asInstanceOf[js.Any])
    if (!js.isUndefined(acosh)) __obj.updateDynamic("acosh")(acosh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(add)) __obj.updateDynamic("add")(add.get.asInstanceOf[js.Any])
    if (!js.isUndefined(asin)) __obj.updateDynamic("asin")(asin.get.asInstanceOf[js.Any])
    if (!js.isUndefined(asinh)) __obj.updateDynamic("asinh")(asinh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(assignment)) __obj.updateDynamic("assignment")(assignment.get.asInstanceOf[js.Any])
    if (!js.isUndefined(atan)) __obj.updateDynamic("atan")(atan.get.asInstanceOf[js.Any])
    if (!js.isUndefined(atanh)) __obj.updateDynamic("atanh")(atanh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(cbrt)) __obj.updateDynamic("cbrt")(cbrt.get.asInstanceOf[js.Any])
    if (!js.isUndefined(ceil)) __obj.updateDynamic("ceil")(ceil.get.asInstanceOf[js.Any])
    if (!js.isUndefined(comparison)) __obj.updateDynamic("comparison")(comparison.get.asInstanceOf[js.Any])
    if (!js.isUndefined(concatenate)) __obj.updateDynamic("concatenate")(concatenate.get.asInstanceOf[js.Any])
    if (!js.isUndefined(conditional)) __obj.updateDynamic("conditional")(conditional.get.asInstanceOf[js.Any])
    if (!js.isUndefined(cos)) __obj.updateDynamic("cos")(cos.get.asInstanceOf[js.Any])
    if (!js.isUndefined(cosh)) __obj.updateDynamic("cosh")(cosh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(divide)) __obj.updateDynamic("divide")(divide.get.asInstanceOf[js.Any])
    if (!js.isUndefined(exp)) __obj.updateDynamic("exp")(exp.get.asInstanceOf[js.Any])
    if (!js.isUndefined(expm1)) __obj.updateDynamic("expm1")(expm1.get.asInstanceOf[js.Any])
    if (!js.isUndefined(factorial)) __obj.updateDynamic("factorial")(factorial.get.asInstanceOf[js.Any])
    if (!js.isUndefined(floor)) __obj.updateDynamic("floor")(floor.get.asInstanceOf[js.Any])
    if (!js.isUndefined(fndef)) __obj.updateDynamic("fndef")(fndef.get.asInstanceOf[js.Any])
    if (!js.isUndefined(in)) __obj.updateDynamic("in")(in.get.asInstanceOf[js.Any])
    if (!js.isUndefined(length)) __obj.updateDynamic("length")(length.get.asInstanceOf[js.Any])
    if (!js.isUndefined(lg)) __obj.updateDynamic("lg")(lg.get.asInstanceOf[js.Any])
    if (!js.isUndefined(ln)) __obj.updateDynamic("ln")(ln.get.asInstanceOf[js.Any])
    if (!js.isUndefined(log)) __obj.updateDynamic("log")(log.get.asInstanceOf[js.Any])
    if (!js.isUndefined(log10)) __obj.updateDynamic("log10")(log10.get.asInstanceOf[js.Any])
    if (!js.isUndefined(log1p)) __obj.updateDynamic("log1p")(log1p.get.asInstanceOf[js.Any])
    if (!js.isUndefined(log2)) __obj.updateDynamic("log2")(log2.get.asInstanceOf[js.Any])
    if (!js.isUndefined(logical)) __obj.updateDynamic("logical")(logical.get.asInstanceOf[js.Any])
    if (!js.isUndefined(max)) __obj.updateDynamic("max")(max.get.asInstanceOf[js.Any])
    if (!js.isUndefined(min)) __obj.updateDynamic("min")(min.get.asInstanceOf[js.Any])
    if (!js.isUndefined(multiply)) __obj.updateDynamic("multiply")(multiply.get.asInstanceOf[js.Any])
    if (!js.isUndefined(power)) __obj.updateDynamic("power")(power.get.asInstanceOf[js.Any])
    if (!js.isUndefined(random)) __obj.updateDynamic("random")(random.get.asInstanceOf[js.Any])
    if (!js.isUndefined(remainder)) __obj.updateDynamic("remainder")(remainder.get.asInstanceOf[js.Any])
    if (!js.isUndefined(round)) __obj.updateDynamic("round")(round.get.asInstanceOf[js.Any])
    if (!js.isUndefined(sign)) __obj.updateDynamic("sign")(sign.get.asInstanceOf[js.Any])
    if (!js.isUndefined(sin)) __obj.updateDynamic("sin")(sin.get.asInstanceOf[js.Any])
    if (!js.isUndefined(sinh)) __obj.updateDynamic("sinh")(sinh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(sqrt)) __obj.updateDynamic("sqrt")(sqrt.get.asInstanceOf[js.Any])
    if (!js.isUndefined(subtract)) __obj.updateDynamic("subtract")(subtract.get.asInstanceOf[js.Any])
    if (!js.isUndefined(tan)) __obj.updateDynamic("tan")(tan.get.asInstanceOf[js.Any])
    if (!js.isUndefined(tanh)) __obj.updateDynamic("tanh")(tanh.get.asInstanceOf[js.Any])
    if (!js.isUndefined(trunc)) __obj.updateDynamic("trunc")(trunc.get.asInstanceOf[js.Any])
    __obj.asInstanceOf[Abs]
  }
}


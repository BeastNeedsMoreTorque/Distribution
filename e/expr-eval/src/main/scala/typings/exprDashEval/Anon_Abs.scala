package typings.exprDashEval

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait Anon_Abs extends js.Object {
  var abs: js.UndefOr[Boolean] = js.undefined
  var acos: js.UndefOr[Boolean] = js.undefined
  var acosh: js.UndefOr[Boolean] = js.undefined
  var add: js.UndefOr[Boolean] = js.undefined
  var asin: js.UndefOr[Boolean] = js.undefined
  var asinh: js.UndefOr[Boolean] = js.undefined
  var atan: js.UndefOr[Boolean] = js.undefined
  var atanh: js.UndefOr[Boolean] = js.undefined
  var ceil: js.UndefOr[Boolean] = js.undefined
  var comparison: js.UndefOr[Boolean] = js.undefined
  var concatenate: js.UndefOr[Boolean] = js.undefined
  var conditional: js.UndefOr[Boolean] = js.undefined
  var cos: js.UndefOr[Boolean] = js.undefined
  var cosh: js.UndefOr[Boolean] = js.undefined
  var divide: js.UndefOr[Boolean] = js.undefined
  var exp: js.UndefOr[Boolean] = js.undefined
  var factorial: js.UndefOr[Boolean] = js.undefined
  var floor: js.UndefOr[Boolean] = js.undefined
  var in: js.UndefOr[Boolean] = js.undefined
  var length: js.UndefOr[Boolean] = js.undefined
  var lg: js.UndefOr[Boolean] = js.undefined
  var ln: js.UndefOr[Boolean] = js.undefined
  var log: js.UndefOr[Boolean] = js.undefined
  var log10: js.UndefOr[Boolean] = js.undefined
  var logical: js.UndefOr[Boolean] = js.undefined
  var multiply: js.UndefOr[Boolean] = js.undefined
  var power: js.UndefOr[Boolean] = js.undefined
  var remainder: js.UndefOr[Boolean] = js.undefined
  var round: js.UndefOr[Boolean] = js.undefined
  var sin: js.UndefOr[Boolean] = js.undefined
  var sinh: js.UndefOr[Boolean] = js.undefined
  var sqrt: js.UndefOr[Boolean] = js.undefined
  var subtract: js.UndefOr[Boolean] = js.undefined
  var tan: js.UndefOr[Boolean] = js.undefined
  var tanh: js.UndefOr[Boolean] = js.undefined
  var trunc: js.UndefOr[Boolean] = js.undefined
}

object Anon_Abs {
  @scala.inline
  def apply(
    abs: js.UndefOr[Boolean] = js.undefined,
    acos: js.UndefOr[Boolean] = js.undefined,
    acosh: js.UndefOr[Boolean] = js.undefined,
    add: js.UndefOr[Boolean] = js.undefined,
    asin: js.UndefOr[Boolean] = js.undefined,
    asinh: js.UndefOr[Boolean] = js.undefined,
    atan: js.UndefOr[Boolean] = js.undefined,
    atanh: js.UndefOr[Boolean] = js.undefined,
    ceil: js.UndefOr[Boolean] = js.undefined,
    comparison: js.UndefOr[Boolean] = js.undefined,
    concatenate: js.UndefOr[Boolean] = js.undefined,
    conditional: js.UndefOr[Boolean] = js.undefined,
    cos: js.UndefOr[Boolean] = js.undefined,
    cosh: js.UndefOr[Boolean] = js.undefined,
    divide: js.UndefOr[Boolean] = js.undefined,
    exp: js.UndefOr[Boolean] = js.undefined,
    factorial: js.UndefOr[Boolean] = js.undefined,
    floor: js.UndefOr[Boolean] = js.undefined,
    in: js.UndefOr[Boolean] = js.undefined,
    length: js.UndefOr[Boolean] = js.undefined,
    lg: js.UndefOr[Boolean] = js.undefined,
    ln: js.UndefOr[Boolean] = js.undefined,
    log: js.UndefOr[Boolean] = js.undefined,
    log10: js.UndefOr[Boolean] = js.undefined,
    logical: js.UndefOr[Boolean] = js.undefined,
    multiply: js.UndefOr[Boolean] = js.undefined,
    power: js.UndefOr[Boolean] = js.undefined,
    remainder: js.UndefOr[Boolean] = js.undefined,
    round: js.UndefOr[Boolean] = js.undefined,
    sin: js.UndefOr[Boolean] = js.undefined,
    sinh: js.UndefOr[Boolean] = js.undefined,
    sqrt: js.UndefOr[Boolean] = js.undefined,
    subtract: js.UndefOr[Boolean] = js.undefined,
    tan: js.UndefOr[Boolean] = js.undefined,
    tanh: js.UndefOr[Boolean] = js.undefined,
    trunc: js.UndefOr[Boolean] = js.undefined
  ): Anon_Abs = {
    val __obj = js.Dynamic.literal()
    if (!js.isUndefined(abs)) __obj.updateDynamic("abs")(abs)
    if (!js.isUndefined(acos)) __obj.updateDynamic("acos")(acos)
    if (!js.isUndefined(acosh)) __obj.updateDynamic("acosh")(acosh)
    if (!js.isUndefined(add)) __obj.updateDynamic("add")(add)
    if (!js.isUndefined(asin)) __obj.updateDynamic("asin")(asin)
    if (!js.isUndefined(asinh)) __obj.updateDynamic("asinh")(asinh)
    if (!js.isUndefined(atan)) __obj.updateDynamic("atan")(atan)
    if (!js.isUndefined(atanh)) __obj.updateDynamic("atanh")(atanh)
    if (!js.isUndefined(ceil)) __obj.updateDynamic("ceil")(ceil)
    if (!js.isUndefined(comparison)) __obj.updateDynamic("comparison")(comparison)
    if (!js.isUndefined(concatenate)) __obj.updateDynamic("concatenate")(concatenate)
    if (!js.isUndefined(conditional)) __obj.updateDynamic("conditional")(conditional)
    if (!js.isUndefined(cos)) __obj.updateDynamic("cos")(cos)
    if (!js.isUndefined(cosh)) __obj.updateDynamic("cosh")(cosh)
    if (!js.isUndefined(divide)) __obj.updateDynamic("divide")(divide)
    if (!js.isUndefined(exp)) __obj.updateDynamic("exp")(exp)
    if (!js.isUndefined(factorial)) __obj.updateDynamic("factorial")(factorial)
    if (!js.isUndefined(floor)) __obj.updateDynamic("floor")(floor)
    if (!js.isUndefined(in)) __obj.updateDynamic("in")(in)
    if (!js.isUndefined(length)) __obj.updateDynamic("length")(length)
    if (!js.isUndefined(lg)) __obj.updateDynamic("lg")(lg)
    if (!js.isUndefined(ln)) __obj.updateDynamic("ln")(ln)
    if (!js.isUndefined(log)) __obj.updateDynamic("log")(log)
    if (!js.isUndefined(log10)) __obj.updateDynamic("log10")(log10)
    if (!js.isUndefined(logical)) __obj.updateDynamic("logical")(logical)
    if (!js.isUndefined(multiply)) __obj.updateDynamic("multiply")(multiply)
    if (!js.isUndefined(power)) __obj.updateDynamic("power")(power)
    if (!js.isUndefined(remainder)) __obj.updateDynamic("remainder")(remainder)
    if (!js.isUndefined(round)) __obj.updateDynamic("round")(round)
    if (!js.isUndefined(sin)) __obj.updateDynamic("sin")(sin)
    if (!js.isUndefined(sinh)) __obj.updateDynamic("sinh")(sinh)
    if (!js.isUndefined(sqrt)) __obj.updateDynamic("sqrt")(sqrt)
    if (!js.isUndefined(subtract)) __obj.updateDynamic("subtract")(subtract)
    if (!js.isUndefined(tan)) __obj.updateDynamic("tan")(tan)
    if (!js.isUndefined(tanh)) __obj.updateDynamic("tanh")(tanh)
    if (!js.isUndefined(trunc)) __obj.updateDynamic("trunc")(trunc)
    __obj.asInstanceOf[Anon_Abs]
  }
}


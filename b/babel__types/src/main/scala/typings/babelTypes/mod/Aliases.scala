package typings.babelTypes.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait Aliases extends js.Object {
  var Binary: typings.babelTypes.mod.Binary
  var Block: typings.babelTypes.mod.Block
  var BlockParent: typings.babelTypes.mod.BlockParent
  var Class: typings.babelTypes.mod.Class
  var CompletionStatement: typings.babelTypes.mod.CompletionStatement
  var Conditional: typings.babelTypes.mod.Conditional
  var Declaration: typings.babelTypes.mod.Declaration
  var EnumBody: typings.babelTypes.mod.EnumBody
  var EnumMember: typings.babelTypes.mod.EnumMember
  var ExportDeclaration: typings.babelTypes.mod.ExportDeclaration
  var Expression: typings.babelTypes.mod.Expression
  var ExpressionWrapper: typings.babelTypes.mod.ExpressionWrapper
  var Flow: typings.babelTypes.mod.Flow
  var FlowBaseAnnotation: typings.babelTypes.mod.FlowBaseAnnotation
  var FlowDeclaration: typings.babelTypes.mod.FlowDeclaration
  var FlowPredicate: typings.babelTypes.mod.FlowPredicate
  var FlowType: typings.babelTypes.mod.FlowType
  var For: typings.babelTypes.mod.For
  var ForXStatement: typings.babelTypes.mod.ForXStatement
  var Function: typings.babelTypes.mod.Function
  var FunctionParent: typings.babelTypes.mod.FunctionParent
  var Immutable: typings.babelTypes.mod.Immutable
  var JSX: typings.babelTypes.mod.JSX
  var LVal: typings.babelTypes.mod.LVal
  var Literal: typings.babelTypes.mod.Literal
  var Loop: typings.babelTypes.mod.Loop
  var Method: typings.babelTypes.mod.Method
  var ModuleDeclaration: typings.babelTypes.mod.ModuleDeclaration
  var ModuleSpecifier: typings.babelTypes.mod.ModuleSpecifier
  var ObjectMember: typings.babelTypes.mod.ObjectMember
  var Pattern: typings.babelTypes.mod.Pattern
  var PatternLike: typings.babelTypes.mod.PatternLike
  var Private: typings.babelTypes.mod.Private
  var Property: typings.babelTypes.mod.Property
  var Pureish: typings.babelTypes.mod.Pureish
  var Scopable: typings.babelTypes.mod.Scopable
  var Statement: typings.babelTypes.mod.Statement
  var TSEntityName: typings.babelTypes.mod.TSEntityName
  var TSType: typings.babelTypes.mod.TSType
  var TSTypeElement: typings.babelTypes.mod.TSTypeElement
  var Terminatorless: typings.babelTypes.mod.Terminatorless
  var UnaryLike: typings.babelTypes.mod.UnaryLike
  var UserWhitespacable: typings.babelTypes.mod.UserWhitespacable
  var While: typings.babelTypes.mod.While
}

object Aliases {
  @scala.inline
  def apply(
    Binary: Binary,
    Block: Block,
    BlockParent: BlockParent,
    Class: Class,
    CompletionStatement: CompletionStatement,
    Conditional: Conditional,
    Declaration: Declaration,
    EnumBody: EnumBody,
    EnumMember: EnumMember,
    ExportDeclaration: ExportDeclaration,
    Expression: Expression,
    ExpressionWrapper: ExpressionWrapper,
    Flow: Flow,
    FlowBaseAnnotation: FlowBaseAnnotation,
    FlowDeclaration: FlowDeclaration,
    FlowPredicate: FlowPredicate,
    FlowType: FlowType,
    For: For,
    ForXStatement: ForXStatement,
    Function: Function,
    FunctionParent: FunctionParent,
    Immutable: Immutable,
    JSX: JSX,
    LVal: LVal,
    Literal: Literal,
    Loop: Loop,
    Method: Method,
    ModuleDeclaration: ModuleDeclaration,
    ModuleSpecifier: ModuleSpecifier,
    ObjectMember: ObjectMember,
    Pattern: Pattern,
    PatternLike: PatternLike,
    Private: Private,
    Property: Property,
    Pureish: Pureish,
    Scopable: Scopable,
    Statement: Statement,
    TSEntityName: TSEntityName,
    TSType: TSType,
    TSTypeElement: TSTypeElement,
    Terminatorless: Terminatorless,
    UnaryLike: UnaryLike,
    UserWhitespacable: UserWhitespacable,
    While: While
  ): Aliases = {
    val __obj = js.Dynamic.literal(Binary = Binary.asInstanceOf[js.Any], Block = Block.asInstanceOf[js.Any], BlockParent = BlockParent.asInstanceOf[js.Any], Class = Class.asInstanceOf[js.Any], CompletionStatement = CompletionStatement.asInstanceOf[js.Any], Conditional = Conditional.asInstanceOf[js.Any], Declaration = Declaration.asInstanceOf[js.Any], EnumBody = EnumBody.asInstanceOf[js.Any], EnumMember = EnumMember.asInstanceOf[js.Any], ExportDeclaration = ExportDeclaration.asInstanceOf[js.Any], Expression = Expression.asInstanceOf[js.Any], ExpressionWrapper = ExpressionWrapper.asInstanceOf[js.Any], Flow = Flow.asInstanceOf[js.Any], FlowBaseAnnotation = FlowBaseAnnotation.asInstanceOf[js.Any], FlowDeclaration = FlowDeclaration.asInstanceOf[js.Any], FlowPredicate = FlowPredicate.asInstanceOf[js.Any], FlowType = FlowType.asInstanceOf[js.Any], For = For.asInstanceOf[js.Any], ForXStatement = ForXStatement.asInstanceOf[js.Any], Function = Function.asInstanceOf[js.Any], FunctionParent = FunctionParent.asInstanceOf[js.Any], Immutable = Immutable.asInstanceOf[js.Any], JSX = JSX.asInstanceOf[js.Any], LVal = LVal.asInstanceOf[js.Any], Literal = Literal.asInstanceOf[js.Any], Loop = Loop.asInstanceOf[js.Any], Method = Method.asInstanceOf[js.Any], ModuleDeclaration = ModuleDeclaration.asInstanceOf[js.Any], ModuleSpecifier = ModuleSpecifier.asInstanceOf[js.Any], ObjectMember = ObjectMember.asInstanceOf[js.Any], Pattern = Pattern.asInstanceOf[js.Any], PatternLike = PatternLike.asInstanceOf[js.Any], Private = Private.asInstanceOf[js.Any], Property = Property.asInstanceOf[js.Any], Pureish = Pureish.asInstanceOf[js.Any], Scopable = Scopable.asInstanceOf[js.Any], Statement = Statement.asInstanceOf[js.Any], TSEntityName = TSEntityName.asInstanceOf[js.Any], TSType = TSType.asInstanceOf[js.Any], TSTypeElement = TSTypeElement.asInstanceOf[js.Any], Terminatorless = Terminatorless.asInstanceOf[js.Any], UnaryLike = UnaryLike.asInstanceOf[js.Any], UserWhitespacable = UserWhitespacable.asInstanceOf[js.Any], While = While.asInstanceOf[js.Any])
    __obj.asInstanceOf[Aliases]
  }
}


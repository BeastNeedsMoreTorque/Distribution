package typings
package workboxDashSwLib.workboxDashSwMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * The Router can be used to process a FetchEvent through one or more
  * Routes responding  with a Request if
  * a matching route exists.
  *
  * If no route matches a given a request, the Router will use a "default"
  * handler if one is defined.
  *
  * Should the matching Route throw an error, the Router will use a "catch"
  * handler if one is defined to gracefully deal with issues and respond with a
  * Request.
  *
  * If a request matches multiple routes, the **earliest** registered route will
  * be used to respond to the request.
  */
trait Router extends js.Object {
  /**
  	 * A `Map` of HTTP method name ('GET', etc.) to an array of all the corresponding `Route`
  	 * instances that are registered.
  	 * @type {Map<string, Route[]>}
  	 */
  val routes: stdLib.Map[java.lang.String, js.Array[Route]]
  /**
  	 * Adds a message event listener for URLs to cache from the window.
  	 * This is useful to cache resources loaded on the page prior to when the
  	 * service worker started controlling it.
  	 *
  	 * The format of the message data sent from the window should be as follows.
  	 * Where the `urlsToCache` array may consist of URL strings or an array of
  	 * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
  	 *
  	 * ```
  	 * {
  	 *   type: 'CACHE_URLS',
  	 *   payload: {
  	 *     urlsToCache: [
  	 *       './script1.js',
  	 *       './script2.js',
  	 *       ['./script3.js', {mode: 'no-cors'}],
  	 *     ],
  	 *   },
  	 * }
  	 * ```
  	 */
  def addCacheListener(): scala.Unit
  /**
  	 * Adds a fetch event listener to respond to events when a route matches
  	 * the event's request.
  	 */
  def addFetchListener(): scala.Unit
  /**
  	 * Checks a request and URL (and optionally an event) against the list of
  	 * registered routes, and if there's a match, returns the corresponding
  	 * route along with any params generated by the match.
  	 * @param {FindMatchingRouteOptions} options
  	 * @return {Partial<FindMatchingRouteResult>}
  	 */
  def findMatchingRoute(options: FindMatchingRouteOptions): stdLib.Partial[FindMatchingRouteResult]
  /**
  	 * Apply the routing rules to a FetchEvent object to get a Response from an
  	 * appropriate Route's handler.
  	 * @param {HandleRequestOptions} options
  	 * @returns {Promise<Response>?} A promise is returned if a registered route can handle the request. If there is no matching route and there's no `defaultHandler`, `undefined` is returned.
  	 */
  def handleRequest(options: HandleRequestOptions): js.UndefOr[js.Promise[stdLib.Response]]
  /**
  	 * Registers a route with the router.
  	 * @param {Route} route - The route to register.
  	 */
  def registerRoute(route: Route): scala.Unit
  /**
  	 * If a Route throws an error while handling a request, this `handler`
  	 * will be called and given a chance to provide a response.
  	 * @param {HandlerCallback} handler - A callback function that returns a Promise resulting in a Response.
  	 */
  def setCatchHandler(handler: HandlerCallback): scala.Unit
  /**
  	 * Define a default `handler` that's called when no routes explicitly
  	 * match the incoming request.
  	 *
  	 * Without a default handler, unmatched requests will go against the
  	 * network as if there were no service worker present.
  	 * @param {HandlerCallback} handler -    * @param {workbox.routing.Route~handlerCallback} handler A callback function that returns a Promise resulting in a Response.
  	 */
  def setDefaultHandler(handler: HandlerCallback): scala.Unit
  /**
  	 * Unregisters a route with the router.
  	 * @param {Route} route - The route to unregister.
  	 */
  def unregisterRoute(route: Route): scala.Unit
}

object Router {
  @scala.inline
  def apply(
    addCacheListener: () => scala.Unit,
    addFetchListener: () => scala.Unit,
    findMatchingRoute: FindMatchingRouteOptions => stdLib.Partial[FindMatchingRouteResult],
    handleRequest: HandleRequestOptions => js.UndefOr[js.Promise[stdLib.Response]],
    registerRoute: Route => scala.Unit,
    routes: stdLib.Map[java.lang.String, js.Array[Route]],
    setCatchHandler: HandlerCallback => scala.Unit,
    setDefaultHandler: HandlerCallback => scala.Unit,
    unregisterRoute: Route => scala.Unit
  ): Router = {
    val __obj = js.Dynamic.literal(addCacheListener = js.Any.fromFunction0(addCacheListener), addFetchListener = js.Any.fromFunction0(addFetchListener), findMatchingRoute = js.Any.fromFunction1(findMatchingRoute), handleRequest = js.Any.fromFunction1(handleRequest), registerRoute = js.Any.fromFunction1(registerRoute), routes = routes, setCatchHandler = js.Any.fromFunction1(setCatchHandler), setDefaultHandler = js.Any.fromFunction1(setDefaultHandler), unregisterRoute = js.Any.fromFunction1(unregisterRoute))
  
    __obj.asInstanceOf[Router]
  }
}

